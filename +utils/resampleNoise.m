function noise_out = resampleNoise(noise, test_idx, ref_idx, test_wts, ref_wts)
% noise_out = resampleCovMtx(noise, test_idx, ref_idx, test_wts, ref_wts)
%
% Resample a noise matrix based on a set of reference and test 
% indices.  This assumes a linear combination of the test and reference 
% vectors.  The output is an n_pair x n_sample matrix of resampled noise.
%
% The intention is to allow for noise to be generated for each sensor
% individually (or with correlation as necessary between sensor
% measurements), but to output the noise that results from difference
% operations on the component measurements.
%
% If the input noiseMtx follows a covariance matrix C, then the output
% noise_out follows the covariance matrix generated by resampleCovMtx with
% C as its input, and the test and reference indices provided here.
%
% The measurements can be optionally weighted, to over-emphasize some
% measurements and de-emphasize others.
%
% Any indices that are NaN will be ignored, to represent a single-sensor
% measurement, such as AoA (which does not need a reference sensor
% measurement against which to compare), or a noise-free measurement with
% no error.
%
% If the third input, ref_idx, is missing or empty, then the second input,
% test_idx, will be passed to utils.parseReferenceSensor to generate
% matching test and reference vectors.
%
% INPUTS:
%   noise       N x n_sample matrix of individual sensor noise measurements
%   test_idx    n_pair x 1 vector of test sensor indices
%   ref_idx     n_pair x 1 vector of reference sensor indices [Optional]
%   test_wts    Optional n_pair x 1 vector of test measurement weights
%   ref_wts     Optional n_pair x 1 vector of reference measurement weights
%
% OUTPUTS:
%   noise_out   n_pair x n_sample output noise
%
% Nicholas O'Donoughue
% 9 June 2021

%% Input handling
% Parse array sizes and indices
[n_sensor, n_sample] = size(noise);

% Handle test/reference inputs
if nargin < 3 || isempty(ref_idx)
    [test_idx, ref_idx] = utils.parseReferenceSensor(test_idx, n_sensor);
end

% Parse output size
n_test = numel(test_idx);
n_ref = numel(ref_idx);
n_out = max(n_test, n_ref);

if n_test > 1 && n_ref > 1 && n_test ~= n_ref
    error(strcat("Error calling covariance matrix resample. Reference and", ...
                 " test vectors must have the same shape."))
end

if any(test_idx > n_sensor) || any(ref_idx > n_sensor)
	error(strcat("Error calling covariance matrix resample. Indices exceed", ...
                 " the dimensions of the covariance matrix."))
end

% Parse sensor weights
do_test_wt = ~(nargin < 4 || isempty(test_wts));
do_ref_wt = ~(nargin < 5 || isempty(ref_wts));

if do_test_wt
    n_test_wt = numel(test_wts);
end

if do_ref_wt
    n_ref_wt = numel(ref_wts);
end

% Initialize output
noise_out = zeros(n_out, n_sample);

% Step through reference sensors
for idx_row = 1:n_out
    % Parse sensor indices.  The mod commands seamlessly handle scalar
    % inputs
    this_test_idx = test_idx(1+mod(idx_row-1, n_test));
    this_ref_idx = ref_idx(1+mod(idx_row-1, n_ref));

    % Parse sensor weights
    if do_test_wt
        this_test_wt = test_wts(1+mod(idx_row-1, n_test_wt));
    else
        this_test_wt = 1;
    end

    if do_ref_wt
        this_ref_wt = ref_wts(1+mod(idx_row-1, n_ref_wt));
    else
        this_ref_wt = 1;
    end


    if isnan(this_ref_idx)
        noise_out(idx_row, :) = this_test_wt * noise(this_test_idx, :);
    elseif isnan(this_test_idx)
        noise_out(idx_row, :) = this_ref_wt * noise(this_ref_idx, :);
    else
        noise_out(idx_row,:) = this_test_wt * noise(this_test_idx, :) - ...
                    this_ref_wt * noise(this_ref_idx, :);
    end
    
end